\section{Protocolli di coerenza}
La coerenza può essere definita formalmente tramite un appropriato invariante, scelto equivalentemente tra:

\begin{itemize}
    \item \textbf{SWMR} (Single Writer Multiple Reader): Durante una data epoca, o c'è un singolo core che può leggere o scrivere la locazione A, oppure un numero di cores che possono solo leggerla.
    \item \textbf{DV} (Data Value): Il valore di A all'inizio di un'epoca è lo stesso valore di A alla fine della sua ultima epoca di lettura/scrittura. 
\end{itemize}

\noindent
Altre opzioni per i protocolli di coerenza sono operazioni di \textbf{Update}, di fatto transazioni che aggiornano tutte le copie nelle altre cache su una scrittura, o \textbf{Invalidate}, transazioni che invalidano tutte le altre copie su una scrittura. 

\noindent Il protocollo determina la macchina a stati finiti nelle cache e nei controller. Gli inptus alla FSM della cache sono eventi del core (istruzioni di Load/Store, \textit{eviction} di un blocco) e eventi di interconnesione (messaggi \textit{own} e \textit{other's} accettati dall'interconnesione); gli input alla FSM dell'LLC controller sono solo gli eventi di interconnesione. Gli eventi di interconnessione consistono nei messaggi provenienti da altri core diretti al "nostro" core o al memory controller, e nei messaggi \textit{own}: ricevere un messaggio \textit{own} significa che l'interconnesisone ha accettato il messaggio (altrimenti il messaggio risulterebbe \textit{pending} sull'interfaccia di interconnessione). 

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.8\textwidth]{fig/chapter_3/FSM.png}}
\end{figure}

\begin{info}
    Una macchina a stati finiti funziona descrivendo un sistema che può trovarsi in un insieme limitato di stati e che cambia stato in base agli ingressi ricevuti. In ogni istante la macchina si trova in uno stato ben preciso, detto stato corrente. Quando riceve un input, consulta le regole di transizione per capire in quale nuovo stato deve andare. A seconda del modello, la macchina può anche produrre un output che dipende solo dallo stato (nel caso di una FSM di Moore) oppure dallo stato e dall'input ricevuto (nel caso di una FSM di Mealy). Questo meccanismo rende le FSM particolarmente utili per descrivere sequenze di eventi o sistemi di controllo.
    Per rappresentarla in una tabella si usa una struttura che mette in relazione gli stati correnti con gli ingressi e specifica quale sarà lo stato successivo e, se previsto, l'output. Una riga della tabella corrisponde a una coppia formata dallo stato corrente e dall'input, mentre le colonne riportano lo stato verso cui si passa e l'eventuale valore di uscita. In questo modo, la tabella diventa una mappa compatta e leggibile che descrive completamente il comportamento della macchina.
\end{info}

\noindent
Un messaggio di tipo \textbf{Get} rappresenta una \textit{richiesta di lettura o allocazione} di un blocco di memoria. Esso viene tipicamente generato da un core quando si verifica un 
\textit{cache miss}, al fine di occupare una linea della cache con il blocco richiesto. 
L'informazione relativa al tipo di richiesta è codificata nel campo \textit{type} del messaggio. 
Quando un core osserva sull'interconnessione un messaggio di tipo Get emesso da un altro core, esso viene interpretato come \textbf{other Get}. In questo caso, il controller deve verificare se il blocco richiesto è eventualmente presente nella propria cache, per rispondere o per aggiornare lo stato del blocco secondo il protocollo di coerenza adottato.  

\noindent
Il messaggio di tipo \textbf{Put}, invece, è un'operazione di \textit{invio proattivo} di un blocco dalla cache verso il livello inferiore della gerarchia. Ciò avviene tipicamente in caso di \textit{eviction}, ossia quando una linea di cache deve essere liberata. In modo analogo al caso precedente, se un core osserva sull’interconnessione un messaggio di tipo Put proveniente da un altro core, questo viene classificato come \textbf{other Put}.  

\noindent
È importante notare che l'emissione di una richiesta da parte di un cache controller non implica necessariamente la sua immediata accettazione: l'interconnessione può infatti trovarsi in stato \textit{busy}. Per questo motivo, il controller mantiene visibilità delle proprie richieste sotto forma di \textbf{own messages}, che fungono da meccanismo di \textit{acknowledgment} da parte dell'interconnessione, consentendo di sincronizzare la generazione e l'elaborazione dei messaggi.  

\subsection{Protocollo a due stati con Writeback}
In questo protocollo basilare entrambe le FSM hanno due stati, V (Valid) e I (Invalid).
Per le FSM delle cache, V significa che il blocco è disponibile nella cache per lettura/scrittura, mentre I significa che il blocco non è presente in cache. Per l'FSM dell'LLC, V significa che il blocco è in qualche cache di livello superiore, I significa che è disponibile solo nell'LLC. 

\noindent Questo protocollo rispetta gli invarianti di coerenza, ma non supporta molteplici repliche dei dati in nodi diversi quando sono usati solo per operazioni di lettura. 

\begin{warn}
    Lavoriamo sotto l'ipotesi che tutti i messaggi sono inviati in broadcast a tutti i controller e sono visti da tutti nello stesso ordine. Un'ulteriore ipotesi è che gli eventi interni e di interconnesione sono \textit{simultanei} (Load miss $\rightarrow$ OwnGet + DataResp).
\end{warn}

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.85\textwidth]{fig/chapter_3/two_state_protocol.png}}
\end{figure}

\noindent Tipicamente l'interconnessione supporta messaggi di controllo e dato separati, perchè i dati hanno bisogno di risorse di interconnessione (bus) dedicati e impiegano molto più tempo rispetto alle informazioni di controllo. 
Di conseguenza, un interazione di richiesta/risposta deve necessariamente essere gestita da due messaggi separati: Il messaggio di richiesta risposta e il messaggio contenente i dati. \uppercase{è} necessario introdurre degli stati \textit{transienti}, per gestire la situazione in cui un messaggio di controllo è arrivato, ma non sono arrivati i dati. 

\begin{warn}
    Per ora assumiamo che se un core sta aspettando i dati in uno stato transiente, non può intervenire una get proveniente da un altro core. 
\end{warn}

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.85\textwidth]{fig/chapter_3/two_state_protocol_2.png}}
\end{figure}

\subsection{Protocollo a tre stati}
Per permettere la lettura simultanea di dati condivisi, mantenendo l'invariante SWMR, introduciamo il protocollo a tre stati \textbf{Modified-Shared-Invalid}. Questo protocllo permette di avere repliche dei dati in cache diverse, tranne per il caso in cui un core vuole scrivere il dato. Dal punto di vista dei core, è necessario distinguere richieste di blocchi che saranno solo letti e richiesti di blocchi che invece dovranno essere scritti. Questo implica la distinzione tra messaggi \textit{getS} (Get Shared) e \textit{getM} (Get Modified). Analogamente servirebbe una distinzione tra i messaggi putM e putS, ma putS in questo caso è superfluo in quanto per l'eviction di un blocco in sola lettura non è necessaria comunicazione (\textit{eviction silente}).

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.6\textwidth]{fig/chapter_3/3_state_fsm.png}}
\end{figure}

\noindent Dal punto di vista dell'LLC, è interessante tracciare solo due stati: o una linea può essere modificata da qualche core oppure \textit{indifferentemente} o qualcuno può solo leggerla o ce l'ha solo LLC. 

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.95\textwidth]{fig/chapter_3/3_state_table.png}}
\end{figure}

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.55\textwidth]{fig/chapter_3/3_state_table_LLC.png}}
\end{figure}

\subsection{Lo stato Exclusive}
\uppercase{è} possibile espandere il numero di stati possibili per gestire al meglio determinate situazioni ricorrenti. Lo stato \textbf{Exclusive} serve a gestire i casi di Load $\rightarrow$ Store. Questp stato è usato in quasi tutti i protocolli di coerenza in commercio, in particolare nei processori ARM. Questo stato ottimizza il caso in cui un core inizialmente legge un blocco, e poi lo sovrascrive. Con il protocollo a tre stati questa situazione è descritta dalla sequenza load miss $\rightarrow$ GetS $\rightarrow$ Write Miss $\rightarrow$ GetM. Aggiungendo lo stato Exclusive, il controller può \textit{silenziosamente} aggiornare lo stato della linea da E $\rightarrow$ M, ma chiaramente solo se è l'unico core ad avere in cache attualmente la linea. 

\begin{warn}
    In realtà al posto di GetM andrebbe usato \textit{Update}, perchè è inutile trasportare i dati di nuovo dopo la GetS.
\end{warn}

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.35\textwidth]{fig/chapter_3/common_situation.png}}
\end{figure}

\noindent \uppercase{è} possibile implementare questo protocollo facendo in modo che il controller LLC abbia traccia di quante caches abbiamo il blocco nello stato S, attraverso un contatore e ricevendo i messaggi PutS, usati dalle cache quando vogliono fare un'operazione di \textit{evict} che fino a questo momento era rimasta silente. In questo modo il controller LLC può tenere traccia di quanti \textit{sharers} esistono, ma al contempo questo aumenta notevolmente il traffico di messaggi per la gestione della coerenza. 

\noindent Esiste una versione \textit{imperfetta} ma meno costosa, che consta di un approccio conservativo. Il controller LLC setta lo stato E di una linea su una prima richiesta di accesso, e nei successivi accessi lo stato muta E $\rightarrow$ S, e non torna mai più allo stato E, anche quando resta solo uno sharer.  

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.55\textwidth]{fig/chapter_3/exclusive_fsm.png}}
\end{figure}

\subsection{Lo stato Owned}
\uppercase{è} possibile introdurre lo stato owner: un \textbf{Owner} è la cache che dispone della versione più aggiornata di una linea. Una cache in stato \textbf{O} deve rispondere alle richieste di altre cache per quel blocco, sollevando il controller LLC da questo onere. Quando una cache ha un blocco nello stato M oppure E, e riceve una GetS da un altro core, nel protocollo MSI, la cache deve rispondere mandando il dato al richiedente e al controller LLC, delegando la \textit{ownership} all'LLC. Il protocollo che include lo stato owned elimina il passaggio per l'LLC.


\subsection{Recap Stati di coerenza}
Dei protocolli visti finora possiamo sintetizzare i vari stati:

\begin{itemize}
    \item \textbf{Modified}: Il blocco è valido, exlusive, owned, e potenzialmente sporco;
    \item \textbf{Shared}: Il blocco è valido ma non esclusivo, pulito e non owned;
    \item \textbf{Invalid}: Il blocco è invalido:
    \item \textbf{Owned}: Il blocco è valido, owned, potenzialmente sporco ma non exclusive;
    \item \textbf{Exclusive}: Il blocco è valido, exclusive e pulito;
\end{itemize}

\begin{figure}[ht]
    \centering
    \setlength{\fboxrule}{0.5pt} % spessore sottile
    \setlength{\fboxsep}{0pt}    % senza spazio interno
    \fbox{\includegraphics[width=0.9\textwidth]{fig/chapter_3/coherence_events.png}}
\end{figure}

\subsection{Rimozione delle ipotesi}
